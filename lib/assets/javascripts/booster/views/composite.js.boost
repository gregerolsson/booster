var base = require('../view');

/**
 * @extends {base.View}
 * @constructor
 */

exports.View = base.View.extend({

  /**
   * Adds a new child view to the composite. This does not add the view to the DOM tree,
   * which needs to be handled by the inheriting view. The added view will get its
   * `enter()` function invoked if it wants to register a link back to this composite.
   *
   * @param {base.View} view The child view to be added to the composite.
   * @return {base.View} The child view that was passed in.
   */

  add: function(view) {
    this.children || (this.children = []);
    this.children.push(view);
    return view.enter(this);
  },

  /**
   * Removes the child view from the composite. This also removes the view from the
   * DOM tree by invoking its `leave()` function, which also unbinds from any underlying
   * model or collection.
   *
   * @param {base.View} view The child view to remove from the composite.
   * @param {base.View|undefined} The view that was removed or `undefined` if it was not in the composite.
   */

  remove: function(view) {
    var index = this.children.indexOf(view);
    if (index > -1) {
      this.children.splice(index, 1);
      delete view.parent;
      return view.leave();
    }
  },


  /**
   * Removes the composite from the parent. Overridden to recursively invoke `leave` on all
   * the child views first.
   *
   * @override
   */

  leave: function() {
    _.each(this.children, function(view) {
      view.leave();
    });

    base.View.prototype.leave.call(this);
  }

});